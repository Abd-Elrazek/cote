{"name":"Cote","tagline":"An auto-discovery mesh network framework for building fault-tolerant and scalable applications","body":"cote\r\n====\r\n\r\ncote is an auto-discovery mesh network framework for building fault-tolerant and scalable applications. It hosts components that let you write programs that discover each other over LAN and communicate in various schemes.\r\n\r\nJoin us on [![cote Slack](http://slack.cotejs.org/badge.svg)](http://slack.cotejs.org) for anything related to cote.\r\n\r\nCote is built upon networking and messaging libraries such as <a href=\"https://github.com/visionmedia/axon\">axon</a> and <a href=\"https://github.com/wankdanker/node-discover\">node-discover</a>.\r\n\r\nMotivation\r\n----\r\n\r\nTomorrow belongs to distributed software. As CPU performance is heavily dictated by the number of cores and the power of each core is already at its limits, distributed computing will decide how your application performs. Distributed systems also pose great architectural benefits such as fault-tolerance and scalability.\r\n\r\nComponents of such a distributed system should be able to find other components <a href=\"http://en.wikipedia.org/wiki/Zero_configuration_networking\">zeroconf</a> and communicate over a set of conventions. Sometimes they may work as a cluster, may include a pub/sub mechanism, or a request/response mechanism. Cote brings you the advantages of distributed software. Think of it like homing pigeons.\r\n\r\nInstalling\r\n----\r\n\r\n* via npm<br>\r\n`npm install cote`\r\n* via git<br>\r\n`git clone git://github.com/dashersw/cote.git`\r\n\r\nComponents\r\n----\r\n\r\nAll components support namespaces. Given as the configuration object to the constructor, components adhere and act on namespaces if provided, and ignore other messages.\r\n\r\n### Requester\r\n\r\nRequester queues requests until a Responder is available, and once so, it delivers the request. Requests will be dispatched to Responders in a round-robin way.\r\n\r\nExample:\r\n```js\r\nvar Requester = require('cote').Requester;\r\n\r\nvar randomRequest = new Requester({\r\n    name: 'randomReq',\r\n    // namespace: 'rnd',\r\n    requests: ['randomRequest']\r\n});\r\n\r\nrandomRequest.on('ready', function() {\r\n    setInterval(function() {\r\n        var req = {\r\n            type: 'randomRequest',\r\n            val: ~~(Math.random() * 10)\r\n        };\r\n\r\n        randomRequest.send(req, function(res) {\r\n            console.log('request', req, 'answer', res);\r\n        });\r\n    }, 5000);\r\n});\r\n```\r\n\r\n### Responder\r\n\r\nResponder is a component for responding to certain requests from a Requester. It's a descendant of EventEmitter2, and requests are regular events, therefore may be wildcarded or namespaced.\r\n\r\nResponder may be used to add new modules to existing web servers / applications without ever changing the main server code. Only a Requester will be able to utilize a Responder.\r\n\r\nExample:\r\n```js\r\nvar Responder = require('cote').Responder;\r\n\r\n// Instantiate a new Responder component.\r\nvar randomResponder = new Responder({\r\n    name: 'randomRep',\r\n    // namespace: 'rnd',\r\n    respondsTo: ['randomRequest'] // types of requests this responder\r\n                                  // can respond to.\r\n});\r\n\r\n// request handlers are like any event handler.\r\nrandomResponder.on('randomRequest', function(req, cb) {\r\n    var answer = ~~(Math.random() * 10);\r\n    console.log('request', req.val, 'answering with', answer);\r\n    cb(answer);\r\n});\r\n```\r\n\r\n### Publisher\r\n\r\nPublisher is a component for publishing certain events with arbitrary data. It may be used as a distributed EventEmitter. It may also be used in a scenario where some components need to be notified of updates, such as new tweets, etc. instead of polling for them. Only a subscriber will get notifications from a Publisher.\r\n\r\nExample:\r\n```js\r\nvar Publisher = require('cote').Publisher;\r\n\r\n// Instantiate a new Publisher component.\r\nvar randomPublisher = new Publisher({\r\n    name: 'randomPub',\r\n    // namespace: 'rnd',\r\n    broadcasts: ['randomUpdate']\r\n});\r\n\r\n// Wait for the publisher to find an open port and listen on it.\r\nrandomPublisher.on('ready', function() {\r\n    setInterval(function() {\r\n        var val = {\r\n            val: ~~(Math.random() * 1000)\r\n        };\r\n\r\n        console.log('emitting', val);\r\n\r\n        // publish an event with arbitrary data at any time\r\n        randomPublisher.publish('randomUpdate', val);\r\n    }, 3000);\r\n});\r\n```\r\n\r\n### Subscriber\r\n\r\nSubscriber subscribes to events emitted from a Publisher.\r\n\r\nExample:\r\n```js\r\nvar Subscriber = require('cote').Subscriber;\r\n\r\nvar randomSubscriber = new Subscriber({\r\n    name: 'randomSub',\r\n    // namespace: 'rnd',\r\n    subscribesTo: ['randomUpdate']\r\n});\r\n\r\nrandomSubscriber.on('randomUpdate', function(req) {\r\n    console.log('notified of ', req);\r\n});\r\n```\r\n\r\n### Sockend\r\n\r\nSockend is the glue for carrying all the possibilities of cote to the next level with WebSockets over socket.io. Sockend makes Responders and Publishers available to the front-end and adhere to socket.io namespaces. It's the magic for distributed web apps.\r\n\r\nExample:\r\n`index.html`\r\n```html\r\n<script src=\"/socket.io/socket.io.js\"></script>\r\n<script>\r\n  var socket = io.connect('http://localhost');\r\n  var socket2 = io.connect('http://localhost/rnd');\r\n\r\n  setInterval(function() {\r\n    var req = {\r\n      val: ~~(Math.random() * 10)\r\n    };\r\n\r\n    var req2 = {\r\n      val: ~~(Math.random() * 10)\r\n    };\r\n\r\n    socket.emit('randomRequest', req, function(data) {\r\n      console.log('normal', req.val, data);\r\n    });\r\n\r\n    socket2.emit('randomRequest', req2, function(data) {\r\n      console.log('ns', req2.val, data);\r\n    });\r\n  }, 3000)\r\n\r\n</script>\r\n```\r\n`sockend.js`\r\n```js\r\nvar app = require('http').createServer(handler)\r\n  , io = require('socket.io').listen(app)\r\n  , fs = require('fs')\r\n\r\napp.listen(5555);\r\n\r\nfunction handler (req, res) {\r\n  fs.readFile(__dirname + '/index.html',\r\n  function (err, data) {\r\n    if (err) {\r\n      res.writeHead(500);\r\n      return res.end('Error loading index.html');\r\n    }\r\n\r\n    res.writeHead(200);\r\n    res.end(data);\r\n  });\r\n};\r\n\r\nvar sockend = new require('../../').Sockend(io, {\r\n  name: 'sockend'\r\n});\r\n```\r\n\r\nNow, fire up a few Responders and Publishers on default or 'rnd' namespace and watch them glow with magic on `http://localhost:5555`.\r\n\r\n### Monitor\r\n\r\nMonitor is the \"top\" of cote. It lists all the daemons it discovers regardless of namespace or key. Run `examples/monitor.js` and see all your active cote daemons.\r\n\r\nMIT License\r\n----\r\n\r\nCopyright (c) 2013 Armagan Amcalar armagan@amcalar.com\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}