<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Management Console</title>
    <style>
        *,
        html,
        body {
            /* typography */
            font-size: 16px;
        }

        h1 {
            /* typography */
            font-size: 2.5rem;
        }

        .node {
            /* visual */
            fill: red;
        }

        .text {
            /* typography */
            font-weight: bold;
        }

        svg {
            /* box-model */
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>
    var socket = io.connect('http://localhost:5555');
</script>

<main>
    <h1>Monitor Cote</h1>
    <div class="svg"></div>
</main>

<script>
    var config = {
        /* SVG variables */
        svgElmSpecifier: '.svg',
        svgWidth: '1000',
        svgHeight: '500',
        nodeRadius: 10,

        /* Text element variables */
        textDx: 10,
        textDy: 10,

        /* Force layout configuration */
        strength: -100, // charge
        distanceMin: 4 // distance min btw nodes
    };

    var svg = d3.select(config.svgElmSpecifier)
            .append('svg')
            .attr('width', config.svgWidth)
            .attr('height', config.svgHeight);

    var nodes = svg.selectAll('g.node');
    var color = d3.scaleOrdinal(d3.schemeCategory10);

    var simulation = d3.forceSimulation()
            .force('charge', d3.forceManyBody().strength(config.strength))
            .force('center', d3.forceCenter(config.svgWidth / 2, config.svgHeight / 2))
            .force("collide", d3.forceCollide().radius(60).iterations(2))
            .on('tick', ticked);

    function update(data) {
        nodes = svg.selectAll('.node')
                .data(data.nodes, function (d) {
                    return d.id;
                });

        nodes.exit().remove();

        var nodeEnter = nodes.enter()
                .append("g")
                .classed("node", true);

        nodeEnter.append('circle')
                .attr('r', config.nodeRadius)
                .attr('fill', function(d) {
                    return color(d.group);
                });

        nodeEnter.append('text')
                .classed('text', true)
                .attr("x", 14)
                .attr("y", ".31em")
                .text(function (d) {
                    return d.name;
                });

        if (nodeEnter.nodes) {
            nodes = nodeEnter.merge(nodes);

            simulation
                    .nodes(data.nodes)
                    .restart();
        }

    }

    function ticked(e) {
        nodes.attr('transform', function (d) {
            return 'translate(' + d.x + ',' + d.y + ')';
        });
    }

    socket.on('statusUpdate', function (data) {
        update(data);
    });
</script>

</body>
</html>
