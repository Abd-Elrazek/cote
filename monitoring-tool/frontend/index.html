<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Management Console</title>
    <style>
        *,
        html,
        body {
            /* typography */
            font-size: 16px;
        }

        h1 {
            /* typography */
            font-size: 2.5rem;
        }

        .node {
            /* visual */
            fill: #be0000;
        }

        .link {
            /* visual */
            stroke: cyan;
        }

        .text {
            /* typography */
            font-weight: bold;
        }

        svg {
            /* box-model */
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/lodash/4.14.0/lodash.min.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<!-- These script are kept to dive deep into force layout of D3, if needed. -->
<!--<script src="//d3js.org/d3-collection.v1.js"></script>-->
<!--<script src="//d3js.org/d3-selection.v1.js"></script>-->
<!--<script src="//d3js.org/d3-timer.v1.js"></script>-->
<!--<script src="//d3js.org/d3-dispatch.v1.js"></script>-->
<!--<script src="//d3js.org/d3-quadtree.v1.js"></script>-->
<!--<script src="https://d3js.org/d3-drag.v1.js"></script>-->
<!--<script src="//d3js.org/d3-force.v1.js"></script>-->

<script src="/socket.io/socket.io.js"></script>
<script>
    var socket = io.connect();
</script>

<main>
    <h1>Monitor Cote</h1>
    <div class="svg"></div>
</main>

<script>
    var config = {
        /* SVG variables */
        svgElmSpecifier: '.svg',
        svgWidth: '1000',
        svgHeight: '500',

        /* Hosts radius */
        host: {
            radius: 15,
            color: 'blue'
        },
        process: {
            radius: 10,
            color: 'green'
        },
        node: {
            radius: 5,
            color: 'cyan'
        },

        /* Text element variables */
        textDx: 10,
        textDy: 10,

        /* Force layout configuration */
        strength: -50, // charge
        distanceMin: 30, // distance min btw nodes

        /* Link configuration */
        linkDistance: {
            hostProcess: 80,
            processNode: 90,
            nodeNode: 100
        },

        linkStrength: {
            hostProcess: 10,
            processNode: 5,
            nodeNode: 1
        },
        linkIterations: 30
    };

    var svg = d3.select(config.svgElmSpecifier)
            .append('svg')
            .attr('width', config.svgWidth)
            .attr('height', config.svgHeight);

    var nodes = svg.selectAll('.node');
    var links = svg.selectAll('.link');

    var simulation = d3.forceSimulation()
            .force('charge', d3.forceManyBody().strength(config.strength))
            .force("link", d3.forceLink()
                    .strength(function(d) {
                        var isHostProcessConnection = isHostProcessConnection(d.source, d.target);
                        var isProcessNodeConnection = isProcessNodeConnection(d.source, d.target);

                        if (isHostProcessConnection) {
                            return config.linkStrength.hostProcess;
                        } else if (isProcessNodeConnection) {
                            return config.linkStrength.processNode;
                        }

                        return config.linkStrength.nodeNode;
                    })
                    .distance(function(d) {
                        var isHostProcessConnection = isHostProcessConnection(d.source, d.target);
                        var isProcessNodeConnection = isProcessNodeConnection(d.source, d.target);

                        if (isHostProcessConnection) {
                            return config.linkDistance.hostProcess;
                        } else if (isProcessNodeConnection) {
                            return config.linkDistance.processNode;
                        }

                        return config.linkDistance.nodeNode;
                    })
                    .iterations(config.linkIterations))
            .force('center', d3.forceCenter(config.svgWidth / 2, config.svgHeight / 2))
            .on('tick', ticked);

    var drag = d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);

    function update(data) {
        // Update links
        links = svg.selectAll(".link")
                .data(data.links);

        links.exit().remove();

        var linkEnter = links.enter()
                .append("line")
                .classed("link", true);

        links = linkEnter.merge(links);

        // Update Nodes
        nodes = svg.selectAll('.node')
                .data(data.nodes, function(d) {
                    return d.id;
                });

        nodes.exit().remove();

        var nodeEnter = nodes.enter()
                .append("g")
                .classed("node", true)
                .call(drag);

        nodeEnter.append('circle')
                .attr('r', function(d) {
                    return config[d.type].radius;
                })
                .attr('fill', function(d) {
                    return config[d.type].color;
                });

        nodeEnter.append('text')
                .classed('text', true)
                .attr("x", 14)
                .attr("y", ".31em")
                .text(function(d) {
                    return d.name;
                });

        nodes = nodeEnter.merge(nodes);

        simulation.nodes(data.nodes);

        simulation.force("link")
                .links(data.links);

        simulation.restart();
        simulation.alpha(1);
    }

    function ticked(e) {
        links.attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

        nodes.attr('transform', function(d) {
            return 'translate(' + d.x + ',' + d.y + ')';
        });
    }

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    function isHostProcessConnection(d) {
        return (d.source.type == 'host' && d.target.type == 'process') ||
                (d.target.type == 'host' && d.source.type == 'process');
    }

    function isProcessNodeConnection(d) {
        return (d.source.type == 'process' && d.target.type == 'node') ||
                (d.source.type == 'node' && d.target.type == 'process');
    }
    }

    socket.on('statusUpdate', function(data) {
        update(data);
    });
</script>

</body>
</html>
